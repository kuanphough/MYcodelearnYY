
## [CONST in C++](https://www.youtube.com/watch?v=4fJBrditnJU&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=33)

1. const
我比较喜欢把const叫做一个"fake keyword"，因为它实际上在生成代码的时候并没有做什么。 它有点像类和结构体的可见性，是一种针对开发人员写代码的强制规则，为了让代码保持整洁的机制。 基本上 const 就是你做出承诺，某些东西是不变的，是不会改动的。但是它只是个承诺，而且你可以绕过或不遵守这个承诺，就像在现实生活中一样。

补充.：constexpr
    constexpr 是 C++11 中新增的关键字，它表示一个值是常量表达式，也就是说它在编译时就计算出来了。 这意味着它可以用于编译时计算，而不是运行时计算。 这对于编译时计算数组大小非常有用，因为数组的大小必须在编译时计算出来。

> [!note] EXample 23.1：const 示例
```cpp
#include <iostream>
#include <string>

int main()


{

    const int MAX_AGE = 90; // 常量，不能被修改
 
   const int* a = new int;
    // 等同于int const* a = new int;
    *a = 2;     
    a = (int*)&MAX_AGE;// 强制类型转换
    std::cout << *a << std::endl;
    std::cin.get();
    // 输出 90
}
```

重点：看const在*的左边还是右边。

```cpp
const int* a = new int;
// 等同于int const* a = new int;
*a = 2;                           // 报错，const使你不能修改a指针指向的内容
a = (int*)&MAX_AGE;
```

```cpp
int* const a = new int;
*a = 2;
a = (int*)&MAX_AGE;               // 报错，可以改变指针指向的内容，但是不能把指针自身重新赋值，让它指向其它东西
```

```cpp
const int* const a = new int;      // 既不能改变指针的内容，也不能改变指针本身让它指向别处
*a = 2;
a = (int*)&MAX_AGE;
```

### Const in Class and Method

> [!note] EXample 23.2：const in Class and Method
```cpp
#include <iostream>
#include <string>

class Entity
{
private:
    int m_X, m_Y;
    mutable int var; // mutable 可以修改
public:
    int GetX() const // 承诺了这个方法不会改变类，是一个只读方法
    {
    //    m_X = 2;       // 无法修改
        var = 2; // 可以修改
        return m_X;
    }
    void SetX(int x) // 可以修改类，不会是const
    {
        m_X = x;
    }
};
void PrintEntity(const Entity& e)
{
    std::cout << e.GetX() << std::endl;
}
int main()
{
    Entity 
    const int MAX_AGE = 90; 
   const int* a = new int;
    *a = 2;     
    a = (int*)&MAX_AGE;
    std::cout << *a << std::endl;
    std::cin.get();

}
```

## [The Mutable Keyword in C++](https://www.youtube.com/watch?v=4fJBrditnJU&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=34)