## 3.Object-Oriented

### [CLASSES in C++ -](https://www.youtube.com/watch?v=2BP8NhxjrO0&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=18)

class是对数据进行分组的方式，或将功能结合在一起。
class本质是一种Type。

class默认设置为private，需要声明public，才能被该类之外的地方可见。
类内部的函数称为方法（methods）。

> [!note] EXample 12.1：创建类玩家，让玩家移动
```cpp
class Player

{

public:

    int x, y;
    int speed;

};

  

void Move(Player& player, int xa, int ya)

{

    player.x += xa * player.speed;

    player.y += ya * player.speed;

}

int main()
{
   Player player;
    Move(player, 1, -1);
    std::cin.get();
}
```

> [!note] EXample 12.1.1：让玩家在类里移动
```cpp
class Player

{
public:

    int x, y;
    int speed;

    void Move(int xa, int ya)
{
    x += xa * speed;
    y += ya * speed;
}
};

int main()
{
   Player player;
   player.Move(1, -1);

    std::cin.get();
}
```

#### [CLASSES vs STRUCTS in C++](https://www.youtube.com/watch?v=fLgTtaqqJp0&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=19)

区别：几乎没有，唯有可见性问题，class默认private，structs默认public。

structs存在的原因：与C保持向后兼容性，因为C没有class

当然也可以，用struct 替换 class，但依旧会弹出class存在错误：

```cpp
#define struct class
```

T.cherno习惯在**只表示数据的结构**中用struct：

> [!note] EXample 12.2：struct
```cpp
struct Vec2
{
float x,y;
void Add(const Vec2& other)
{
    x += other.x;
    y += other.y;
}
};
```

如果涉及到大量功能，他会使用class。

### [How to Write a C++ Class](https://www.youtube.com/watch?v=3dHBFBw13E0&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=21)

示例class log：error、warning、message、trace

用多个public、private区分变量和公式。

> [!note] EXample 13.1：class Log
```cpp
class Log
{
public:
    const int LogLevelError = 0;
    const int LogLevelWarming = 1;
    const int LogLevelInfo = 2;
private:
    int m_LogLevel = LogLevelInfo;//m_来标识它是一个私人成员变量，个人设定，非keyword
public:
    void Setlevel(int level)
    {
        m_LogLevel = level;
    }
    void Error(const char* message)
    {
        if (m_LogLevel >= LogLevelError)
        std::cout << "[ERROR]: " << message << std::endl; 
    }
    void Warn(const char* message)
    {
        if (m_LogLevel >= LogLevelWarming)
        std::cout << "[Warning]: " << message << std::endl;
    }
    void Info(const char* message)
    {
        if (m_LogLevel >= LogLevelInfo)
        std::cout << "[INFO]: " << message << std::endl;
    }
};

int main()
{
    Log log;
    log.Setlevel(log.LogLevelError);
    log.Warn("Hello!");
    log.Error("Hello!");
    log.Info("Hello!");
    std::cin.get();
}
```

### [Static in C++](https://www.youtube.com/watch?v=f3FVU-iwNuA&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=21)
 
 static：类与结构之外者，具有内部含义，只对定义它的翻译单元可见。
 
 类与结构之内者，与该类的所有实例共享内存，和类绑定！
 - 人话：一个公式改变了它的量，其他公式里的它也会同时改变。
 
 1.如果删掉static，会出现LNK错误。
 
 2.如果加上extern，即和外部用同一个变量，外部链接。
 - extern int  s_Variable;
 
 3.如果加上static，main.cpp里的extern int s_Variable会找不到变量。
 
 4.如果加上static，Function()函数只能在本文件中使用，
 
 > [!note] EXample 14.main
 ```cpp
 #include <iostream>
 
 int  s_Variable = 10;
 // 2.如果加上extern，即和外部用同一个变量，外部链接。
 // extern int  s_Variable;
 
 void Function()
 {
 
 }
 
 int main()
 {
     std::cout << s_Variable << std::endl;
     std::cin.get();
 }
 ```
 
 > [!note] EXample 14.static
 ```cpp
 #include <iostream>
 
 static int  s_Variable = 5; 
 // 1.如果删掉static，会出现LNK错误。
 
 // 3.如果加上static，main.cpp里的extern int s_Variable会找不到变量。
 
 static void Function()
 {
     std::cout << s_Variable << std::endl;
     std::cin.get();
 }
 //4.如果加上static，Function()函数只能在本文件中使用，
 ```
 
 #### [Static for Classes and Structs in C++](https://www.youtube.com/watch?v=V-BFlMrBtqQ&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=23)
 
 > [!note] EXample 15.1 一个正常的输出
 ```cpp
 #include <iostream>

struct Entity
{
    int x, y;

    void Print()
    {
        std::cout << x << ", " << y << std::endl;
    }
};

int main()
{
    Entity e;
    e.x = 5;
    e.y = 10;

    Entity e1 = {2, 8};

    e.Print();
    e1.Print();
    std::cin.get();
}
```

 > [!note] EXample 15.2 一个有静态变量但错误的输出
 ```cpp
 struct Entity
 {
     static int x, y;
 
     void Print()
     {
         std::cout << x << ", " << y << std::endl;
     }
 };
 
 int main()
 {
     Entity e;
     e.x = 5;
     e.y = 10;
 
     Entity e1;
     e1.x = 2;
     e1.y = 8;
     // Entity e1 = {2, 8}; // x和y是静态成员变量，而不是class menbers，不能直接初始化。
     //这样会显示无法识别的外部变量。
 
     e.Print();
     e1.Print();
     std::cin.get();
 }
 ```
 
 > [!note] EXample 15.3 一个有静态变量的输出
 ```cpp
 #include <iostream>

struct Entity
{
    static int x, y;

static void Print()
//    void Print()
    {
        std::cout << x << ", " << y << std::endl;
		//如果将line 5静态变量改为普通变量，则会出现报错，因为它没有类实例
    }
};

static void Print(Entity e)
{
    std::cout << Entity::x << ", " << Entity::y << std::endl;
    //但是如果在外部调用struct，line 5改为普通变量时可以使用，因为给了这个函数实例的引用，实例entity是非静态的。
}
int Entity::x = 0; // 静态成员变量必须在类外初始化
int Entity::y = 0; // 静态成员变量必须在类外初始化

int main()
{
    Entity e;
	Entity::x = 5;
    Entity::y = 10;
    //e.x = 5;
    //e.y = 10;

    Entity e1;
    Entity::x = 2;
    Entity::y = 8;
    //e1.x = 2;
    //e1.y = 8;

Entity Print();
//    e.Print();
//    e1.Print();
    std::cin.get();
}
//实质为不断修改static变量和方程，和实例无关。
```

 ### [ENUMS in C++](https://www.youtube.com/watch?v=x55jfOd5PEE&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=24)

对应课本：[C++ Primer 19.3 枚举](https://cpp-primer.pages.dev/book/179-19.3._enumerations.html)

ENUM：给一组值（一般是数字）的名字。
* ENUM CLASS：只能在声明范围内使用。书本例子：

```cpp
enum color {red, yellow, green};      // unscoped enumeration
enum stoplight {red, yellow, green};  // error: redefines enumerators
enum class peppers {red, yellow, green}; // ok: enumerators are hidden
color eyes = green; // ok: enumerators are in scope for an unscoped enumeration
peppers p = green;  // error: enumerators from peppers are not in scope
                    //     color::green is in scope but has the wrong type
color hair = color::red;   // ok: we can explicitly access the enumerators
peppers p2 = peppers::red; // ok: using red from peppers
```

* 内外规定类型要一致。
`enum Example : unsigned char {A = 5,B,C};`

> [!note] EXample 16.1： 一个枚举
```
#include <iostream>

enum Example : unsigned char { // Enum with underlying type unsigned char
    A = 1,
    B = 2,
    C = 3
};

int main() {

    std::cin.get();

}
```

> [!note] EXample 16.2： Log Class里的枚举
```
#include <iostream>

class Log
{
public:
enum Level
{
    LevelError = 0,LevelWarning = 1,LevelInfo = 2
};

private:
    Level m_LogLevel = LevelInfo;//限制在Level范围内
public:
    void Setlevel(Level level)
    {
        m_LogLevel = level;
    }
    void Error(const char* message)
    {
        if (m_LogLevel >= LevelError)
        std::cout << "[ERROR]: " << message << std::endl; 
    }
    void Warn(const char* message)
    {
        if (m_LogLevel >= LevelWarning)
        std::cout << "[Warning]: " << message << std::endl;
    }
    void Info(const char* message)
    {
        if (m_LogLevel >= LevelInfo)
        std::cout << "[INFO]: " << message << std::endl;
    }
};

int main()
{
    Log log;
    log.Setlevel(Log::LevelError);// log类型（命名空间）里的Error类型。
    log.Warn("Hello!");
    log.Error("Hello!");
    log.Info("Hello!");
    std::cin.get();
}
```

### [Constructors in C++](https://www.youtube.com/watch?v=FXhALMsHwEY&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=24)

> [!note] EXample 17.1：没有初始化
```
#include <iostream>

class Entity
{
    public:
    float x, y;

    void Print()
    {
        std::cout << x << ", y << std::endl;
    }
};

int main()
{
    Entity e;
    e.Print();

    std::cin.get();
}
```

output:
两个随机的八位浮点。

我们没有初始那两个内存，这意味着 我们得到了该内存空间中剩余的任何东西。

> [!note] EXample 17.1：没有初始化
```
#include <iostream>

class Entity
{
    public:
    float x, y;

    void Print()
    {
        std::cout << x << ", y << std::endl;
    }
}
int main()
{
    Entity e;
    std::cout << e.X << std::endl;
    e.Print();

    std::cin.get();
}
```

> [!note] EXample 17.1.2：初始化
```
#include <iostream>

class Entity
{
    public:
    float X, Y;

    Entity()
    {

    }

    Entity(float x, float y)
    {
        X = x;
        Y = y;
    }

    void Print()
    {
        std::cout << X << ","<< Y << std::endl;
    }
};

class Log 
{
    private:
    Log(){}//构造函数私有化，禁止创建实例
    public:
    static void Write()
    {
        std::cout << "Log Created" << std::endl;
    }
};
int main()
{
    Log::Write();//只用我的class
//    Log 1;//这里会报错
    Entity e(5.0f, 10.0f);
    e.Print();

    std::cin.get();
}
```

其他类型的构造函数将放在之后讲：等

### [Destructors in C++](https://www.youtube.com/watch?v=D8cWquReFqw&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=25)

当你销毁对象时，析构函数会运行，它适用于堆栈和堆分配的对象。

> [!note] EXample 18.1：析构函数
```
#include <iostream>

class Entity
{
    public:
    float X, Y;

    Entity()
    {
        X = 0.0f;
        Y = 0.0f;
        std::cout << "Constructed Entity" << std::endl;
    }

    ~Entity()//析构函数
    {
        std::cout << "Entity Destroyed" << std::endl; 
    }
    void Print()
    {
        std::cout << X << ","<< Y << std::endl;
    }
};

void Function()
    {
        Entity e;
        e.Print();
    }

int main()
{
    Function();//函数调用，局部变量e在函数结束后会被销毁
    std::cin.get();
}

// 运行结果：
// Constructed Entity
// 0,0
// Entity Destroyed
// 说明：局部变量在函数结束后会被销毁，调用析构函数
}
```

析构函数会在堆栈运行完后运行↑至于为什么是堆栈↓
- 润润：没有new，所以是堆栈
- 润润：`Entity *e = new Entity()` 这种就是在堆上申请空间了。
- 我：懂了，只要没申请空间，都会最后消除实例
- 润润：NO，是因为**在堆栈上创建的变量，所以在生命周期结束的时候，会自动执行析构函数，也就是你说的消除实例**。
- 润润：时间点是**生命周期结束的时候**。
- 润润：因为**new的时候是用指针来引用了那个对象，“指针变量”还是会被回收，但是指针指向的对象不会**。
- 我：哦，指针也被析构了
- 润润：对，指针是个代理人，但是指针没有析构函数()，只是指针这个变量自己的空间被释放了
- 我：哦哦哦，他pop了，pippop~

Cherno谈到有人会手动调用析构函数：
- 一个是new function。
- 另一个是free function，
    - [有关自由函数的讨论 - 知乎](https://www.zhihu.com/question/269676755) 

### [Inheritance in C++](https://www.youtube.com/watch?v=X8nYM8wdNRE&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=26)

- 类的层次结构，它允许我们拥有一个包含常见功能的基类（base），然后它允许我们从该类中分支出来并从初始父类（parent）创建子类（sub）。
  - 能避免代码重复。
  - 子类是父类的superset，包含弗雷的所有参数，因此有时直接调用子类即可。
  - 子类能连同父类的private也一起继承，但是不能直接访问。
    - 一个public方法操作了私有变量，子类可以利用这个public方法来间接访问。【一川答】

> [!note] EXample 19.1：类的继承
```
#include <iostream>

class Entity 
{
public:
    float x, y;

    void Move(float xa, float ya) 
    {
        x += xa;
        y += ya;
    }
};

class Player : public Entity 
{
public:
    const char* name;
    void print() 
    {
        std::cout << name << std::endl;
    }
};

int main() 
{
    std::cout << sizeof(Entity) << std::endl;
    // std::cout << sizeof(Player) << std::endl;
    Player player;
    player.Move(5, 10);
    player.x = 5;
    player.y = 10;

    std::cin.get();
}

//sizeof(Entity)
// Output:
// 8

//sizeof(Player)
//Output:
//12
```

↑一个变量，四个字节。

#### 拓展：多态
Cherno：多态性是一种类型有多种类型的想法

> [!note] **润润小课堂：多态性**
> 多态分为静态多态和动态多态
> **静态多态**是函数的overload，就是多个函数有相同函数名，但是参数不同
> **动态多态**体现在**继承**叫override，子类拥有和父类一样的函数，但是具体的执行内容不同，这个是运行时根据类的虚函数表去查询执行的。

#### 拓展：父指针问题
- 一川：**父类指针**是不是可以自动识别这个实例是子类还是父类来着
- 润润：因为一个对象的内存开头保存了虚函数表的指针，也不叫识别是子类还是父类，都是根据这个指针去执行函数的
- 一川：我记得Cherno那节课讲过一个强制转换成某个派生类，哦，**向下转型**！

---
***以下源自deepseek***

在多重继承的情况下，`static_cast` 是否能正确转换父类与子类，取决于具体的转换方向和继承关系。以下是详细分析：

##### **1. 向上转型（子类 → 父类）**
**场景**：将子类指针/引用转换为父类指针/引用。  
**安全性**：  
- 如果父类是子类的直接公有基类（无论单继承还是多重继承），`static_cast` **是安全的**。编译器能正确调整指针地址，指向父类子对象的内存位置。  
- **多重继承示例**：  
  ```cpp
  class Base1 { /* ... */ };
  class Base2 { /* ... */ };
  class Derived : public Base1, public Base2 { /* ... */ };

  Derived d;
  Base1* b1 = static_cast<Base1*>(&d); // 安全：直接公有基类
  Base2* b2 = static_cast<Base2*>(&d); // 安全：直接公有基类
  ```
  **原理**：  
  编译器知道 `Derived` 对象中 `Base1` 和 `Base2` 子对象的偏移量，能自动调整指针地址。


##### **2. 向下转型（父类 → 子类）**
**场景**：将父类指针/引用转换为子类指针/引用。  
**风险**：  
- **仅在以下情况安全**：  
  父类指针实际指向的是目标子类对象，且开发者能 100% 确定类型关系。  
- **多重继承的隐患**：  
  如果父类指针指向的是其他子类（或同一继承树中的不同分支），`static_cast` **会静默生成错误指针**，导致未定义行为（崩溃、数据损坏等）。  

**示例**：  
```cpp
Base1* b1 = new Base1;  // 父类指针实际指向 Base1 对象
Derived* d = static_cast<Derived*>(b1); // 危险！b1 不是 Derived 对象
d->method(); // 未定义行为：访问非法内存
```

---

##### **3. 复杂多重继承场景**
###### **（1）虚继承（Virtual Inheritance）**
虚基类的内存布局在编译时无法确定（需运行时确定），因此：  
- **向上转型**：`static_cast` 依然安全，编译器能处理虚基类偏移。  
- **向下转型**：`static_cast` **几乎总是危险**，无法正确调整虚基类指针。必须使用 `dynamic_cast`。

###### **（2）交叉转换（Cross Cast）**
**场景**：在多重继承中，将指向一个基类的指针转换为另一个不相关的基类。  
**示例**：  
```cpp
Base1* b1 = new Derived;
Base2* b2 = static_cast<Base2*>(b1); // 编译错误：Base1 和 Base2 无直接继承关系
```
此时必须通过 `Derived` 中转：  
```cpp
Base2* b2 = static_cast<Derived*>(b1); // 先转为子类
b2 = static_cast<Base2*>(static_cast<Derived*>(b1)); // 再转为另一基类
```
但这种操作仍依赖 `b1` 实际指向 `Derived`，否则行为未定义。


##### **4. 与 `dynamic_cast` 的对比**
| 特性                | `static_cast`                          | `dynamic_cast`                          |
|---------------------|----------------------------------------|-----------------------------------------|
| **检查时机**         | 编译时                                | 运行时（依赖 RTTI）                     |
| **安全性**           | 依赖开发者保证逻辑正确                 | 自动验证类型兼容性                      |
| **性能**             | 无额外开销                            | 有运行时开销（遍历继承树）              |
| **适用场景**         | 明确安全的转换（如数值类型、向上转型） | 不确定类型时的向下转型、交叉转换        |
| **失败处理**         | 未定义行为                            | 返回 `nullptr`（指针）或抛出异常（引用）|

---

##### **5. 总结与建议**
- **向上转型**：  
  使用 `static_cast`，安全且高效（编译器保证正确性）。  
- **向下转型**：  
  - 如果无法 100% 确定父类指针实际指向子类对象，**必须使用 `dynamic_cast`**。  
  - 在多重继承或虚继承中，优先用 `dynamic_cast` 避免未定义行为。  
- **交叉转换**：  
  通过 `dynamic_cast` 直接完成，或先转为子类再转目标基类（需确保类型正确）。  

**关键原则**：  
**除非你能完全掌控类型关系，否则优先使用 `dynamic_cast` 保证安全性**。

### [Virtual Functions in C++](https://www.youtube.com/watch?v=oIV2KchSyGQ&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=27)

虚函数允许：Override methods
- **虚函数**：B 是 A 的子类，如果我们如果在 A 类里新建一个方法并把它标记为虚函数，我们可以再 B 类中重写这个方法让它去做其他事情。
  - 虚函数引入了一种要动态分派(dynamic dispatch)的方法，一般通过V table(虚表)来实现编译。 虚表就是一个包含类中所有虚函数映射的列表，通过虚表我们就可以在运行时找到争取的被重写的函数。 简单来说，就是如果你想重写一个函数，那么你必须把基类中的原函数设置为虚函数。
- **虚函数有额外运行成本**
  - 额外的内存用来存储**虚表**[1]，这样我们就可以分配到正确的函数，基类里还有一个指针成员指向虚表。
  - 每次调用虚函数的时候，我们必须要遍历虚表去找到最终要运行的函数，这也是额外的性能损失。
    - 除非是 CPU 很差的嵌入式平台，不会告诉你说：因为性能问题而别去用虚函数，因为它造成的影响很小，你可能根本察觉不到。

[1] 如下 from [C++ 虚函数表 - 世间万物皆代码](https://mp.weixin.qq.com/s/OGhBuDa3N3cyWpPJMkSaEA?scene=1)
> [!note] **小课堂：虚函数表**
> C++中虚函数是通过一张虚函数表(Virtual Table)来实现的，在这个表中，主要是一个类的虚函数表的地址表；这张表解决了继承、覆盖的问题。在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以当我们用父类的指针来操作一个子类的时候，这张虚函数表就像一张地图一样指明了实际所应该调用的函数。
> C++编译器是保证虚函数表的指针存在于对象实例中最前面的位置(是为了保证取到虚函数表的最高的性能)，这样我们就能通过已经实例化的对象的地址得到这张虚函数表，再遍历其中的函数指针，并调用相应的函数。

> [!note] **小课堂：C++类在内存中的存储方式**
> C++ 内存分为 5 个区域：
> - 堆 heap ：由 new 分配的内存块，其释放编译器不去管，由程序员自己控制。如果程序员没有释放掉，在程序结束时系统会自动回收。涉及的问题：“缓冲区溢出”、“内存泄漏”。
> - 栈 stack ：是那些编译器在需要时分配，在不需要时自动清除的存储区。存放局部变量、函数参数。存放在栈中的数据只在当前函数及下一层函数中有效，一旦函数返回了，这些数据也就自动释放了。
> - 全局/静态存储区 （.bss段和.data段） ：全局和静态变量被分配到同一块内存中。在 C 语言中，未初始化的放在.bss段中，初始化的放在.data段中；在 C++ 里则不区分了。
> - 常量存储区 （.rodata段） ：存放常量，不允许修改（通过非正当手段也可以修改）。
> - 代码区 （.text段） ：存放代码（如函数），不允许修改（类似常量存储区），但可以执行（不同于常量存储区）。
> 注意：静态局部变量也存储在全局/静态存储区，作用域为定义它的函数或语句块，生命周期与程序一致。
> 其中对象数据中存储非静态成员变量、虚函数表指针以及虚基类表指针（如果继承多个）。这里就有一个问题，既然对象里不存储类的成员函数的指针，那类的对象是怎么调用公用函数代码的呢？对象对公用函数代码的调用是在编译阶段就已经决定了的，例如有类对象a，成员函数为show()，如果有代码a.show()，那么在编译阶段会解释为 类名::show(&a)。会给show()传一个对象的指针，即this指针。
> 从上面的this指针可以说明一个问题：静态成员函数和非静态成员函数都是在类的定义时放在内存的代码区的，但是类为什么只能直接调用静态成员函数，而非静态成员函数（即使函数没有参数）只有类对象能够调用的问题？原因是类的非静态成员函数其实都内含了一个指向类对象的指针型参数（即this指针），因而只有类对象才能调用（此时this指针有实值）。

>[!note] **20.1 一个普通的继承**
```
#include <iostream>
#include  <string>

class Entity
{
public:
    std::string GetName() { return "Entity"; }//返回字符串
};

class Player : public  Entity
{
private:
    std::string m_Name; //存储玩家名字
public:
    Player(const std::string& name)   //构造函数
        : m_Name(name) {}

    std::string GetName() { return m_Name; }
};

int main()
{
    Entity* e = new Entity();
    std::cout << e->GetName()<< std::endl;

    Player* p = new Player("Cherno");
    std::cout << p->GetName() << std::endl;

    Entity* entity = p;
    std::cout << entity->GetName() << std::endl;

    std::cin.get();
}
```

>[!note] 20.2 因为函数指向父类，所以子类无效
```
void PrintName(Entity* entity)
{
    std::cout << entity->GetName() << std::endl;
}

int main()
{
    Entity* e = new Entity();
    PrintName(e);                             //Entity
    Player* p = new Player("Cherno");
    PrintName(p);                             //Entity

    std::cin.get();
}

// Output: will be "Entity" twice, because the GetName() method in Entity is not virtual.
// To fix this, we need to make the GetName() method virtual in the Entity class.  
// This allows the derived class Player to override the method and return its own name.
```

>[!note] 20.3 将父类标记为虚函数后，再度有效
```
class Entity
{
public:
    virtual std::string GetName() { return "Entity"; }//
};

class Player : public  Entity
{
private:
    std::string m_Name; //存储玩家名字
public:
    Player(const std::string& name)   //构造函数
        : m_Name(name) {}

    std::string GetName() override { return m_Name; }
    // std::string GetName() { return m_Name; } 加上override关键字，表示重写基类的虚函数，更有可读性
};
```

#### [Interfaces in C++ (Pure Virtual Functions)](https://www.youtube.com/watch?v=UWAdd13EfM8&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=28)

**纯虚函数**：定义一个在基类中没有实现的函数，然后强制子类去实现这个函数
**接口（Interface）**:我们通常会创建一个仅包含未实现方法的类，然后强制子类实际实现这些方法，这通常称为接口。

将例20中的Entity类改为：
```
class Entity
{
public:
    virtual std::string GetName() = 0;   // 仍被定义为虚函数，但是=0实际上将它变成了一个纯虚函数
};
```

### [Visibility in C++](https://www.youtube.com/watch?v=6OVQ8nh3KP0&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=30)

可见性：`private`、`protected`、`public`

- private：只有所属的类可以访问
  - friend：可以访问friend标记类的私有成员
- protected：派生的类也可以访问
- public：全公开不是个好主意，难以维护是一点，会让别人调用到本不该接触的代码是第二点

