## 3.Object-Oriented
### [CLASSES in C++ -](https://www.youtube.com/watch?v=2BP8NhxjrO0&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=18)

class是对数据进行分组的方式，或将功能结合在一起。
class本质是一种Type。

class默认设置为private，需要声明public，才能被该类之外的地方可见。
类内部的函数称为方法（methods）。

> [!note] EXample 12.1：创建类玩家，让玩家移动
```cpp
class Player

{

public:

    int x, y;
    int speed;

};

  

void Move(Player& player, int xa, int ya)

{

    player.x += xa * player.speed;

    player.y += ya * player.speed;

}

int main()
{
   Player player;
    Move(player, 1, -1);
    std::cin.get();
}
```

> [!note] EXample 12.1.1：让玩家在类里移动
```cpp
class Player

{
public:

    int x, y;
    int speed;

    void Move(int xa, int ya)
{
    x += xa * speed;
    y += ya * speed;
}
};

int main()
{
   Player player;
   player.Move(1, -1);

    std::cin.get();
}
```

#### [CLASSES vs STRUCTS in C++](https://www.youtube.com/watch?v=fLgTtaqqJp0&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=19)

区别：几乎没有，唯有可见性问题，class默认private，structs默认public。

structs存在的原因：与C保持向后兼容性，因为C没有class

当然也可以，用struct 替换 class，但依旧会弹出class存在错误：

```cpp
#define struct class
```

T.cherno习惯在**只表示数据的结构**中用struct：

> [!note] EXample 12.2：struct
```cpp
struct Vec2
{
float x,y;
void Add(const Vec2& other)
{
    x += other.x;
    y += other.y;
}
};
```

如果涉及到大量功能，他会使用class。

### [How to Write a C++ Class](https://www.youtube.com/watch?v=3dHBFBw13E0&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=21)

示例class log：error、warning、message、trace

用多个public、private区分变量和公式。

> [!note] EXample 13.1：class Log
```cpp
class Log
{
public:
    const int LogLevelError = 0;
    const int LogLevelWarming = 1;
    const int LogLevelInfo = 2;
private:
    int m_LogLevel = LogLevelInfo;//m_来标识它是一个私人成员变量，个人设定，非keyword
public:
    void Setlevel(int level)
    {
        m_LogLevel = level;
    }
    void Error(const char* message)
    {
        if (m_LogLevel >= LogLevelError)
        std::cout << "[ERROR]: " << message << std::endl; 
    }
    void Warn(const char* message)
    {
        if (m_LogLevel >= LogLevelWarming)
        std::cout << "[Warning]: " << message << std::endl;
    }
    void Info(const char* message)
    {
        if (m_LogLevel >= LogLevelInfo)
        std::cout << "[INFO]: " << message << std::endl;
    }
};

int main()
{
    Log log;
    log.Setlevel(log.LogLevelError);
    log.Warn("Hello!");
    log.Error("Hello!");
    log.Info("Hello!");
    std::cin.get();
}
```

### [Static in C++](https://www.youtube.com/watch?v=f3FVU-iwNuA&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=21)
 
 static：类与结构之外者，具有内部含义，只对定义它的翻译单元可见。
 
 类与结构之内者，与该类的所有实例共享内存，和类绑定！
 - 人话：一个公式改变了它的量，其他公式里的它也会同时改变。
 
 1.如果删掉static，会出现LNK错误。
 
 2.如果加上extern，即和外部用同一个变量，外部链接。
 - extern int  s_Variable;
 
 3.如果加上static，main.cpp里的extern int s_Variable会找不到变量。
 
 4.如果加上static，Function()函数只能在本文件中使用，
 
 > [!note] EXample 14.main
 ```cpp
 #include <iostream>
 
 int  s_Variable = 10;
 // 2.如果加上extern，即和外部用同一个变量，外部链接。
 // extern int  s_Variable;
 
 void Function()
 {
 
 }
 
 int main()
 {
     std::cout << s_Variable << std::endl;
     std::cin.get();
 }
 ```
 
 > [!note] EXample 14.static
 ```cpp
 #include <iostream>
 
 static int  s_Variable = 5; 
 // 1.如果删掉static，会出现LNK错误。
 
 // 3.如果加上static，main.cpp里的extern int s_Variable会找不到变量。
 
 static void Function()
 {
     std::cout << s_Variable << std::endl;
     std::cin.get();
 }
 //4.如果加上static，Function()函数只能在本文件中使用，
 ```
 
 #### [Static for Classes and Structs in C++](https://www.youtube.com/watch?v=V-BFlMrBtqQ&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=23)
 
 > [!note] EXample 15.1 一个正常的输出
 ```cpp
 #include <iostream>

struct Entity
{
    int x, y;

    void Print()
    {
        std::cout << x << ", " << y << std::endl;
    }
};

int main()
{
    Entity e;
    e.x = 5;
    e.y = 10;

    Entity e1 = {2, 8};

    e.Print();
    e1.Print();
    std::cin.get();
}
```

 > [!note] EXample 15.2 一个有静态变量但错误的输出
 ```cpp
 struct Entity
 {
     static int x, y;
 
     void Print()
     {
         std::cout << x << ", " << y << std::endl;
     }
 };
 
 int main()
 {
     Entity e;
     e.x = 5;
     e.y = 10;
 
     Entity e1;
     e1.x = 2;
     e1.y = 8;
     // Entity e1 = {2, 8}; // x和y是静态成员变量，而不是class menbers，不能直接初始化。
     //这样会显示无法识别的外部变量。
 
     e.Print();
     e1.Print();
     std::cin.get();
 }
 ```
 
 > [!note] EXample 15.3 一个有静态变量的输出
 ```cpp
 #include <iostream>

struct Entity
{
    static int x, y;

static void Print()
//    void Print()
    {
        std::cout << x << ", " << y << std::endl;
		//如果将line 5静态变量改为普通变量，则会出现报错，因为它没有类实例
    }
};

static void Print(Entity e)
{
    std::cout << Entity::x << ", " << Entity::y << std::endl;
    //但是如果在外部调用struct，line 5改为普通变量时可以使用，因为给了这个函数实例的引用，实例entity是非静态的。
}
int Entity::x = 0; // 静态成员变量必须在类外初始化
int Entity::y = 0; // 静态成员变量必须在类外初始化

int main()
{
    Entity e;
	Entity::x = 5;
    Entity::y = 10;
    //e.x = 5;
    //e.y = 10;

    Entity e1;
    Entity::x = 2;
    Entity::y = 8;
    //e1.x = 2;
    //e1.y = 8;

Entity Print();
//    e.Print();
//    e1.Print();
    std::cin.get();
}
//实质为不断修改static变量和方程，和实例无关。
```

 ### [ENUMS in C++](https://www.youtube.com/watch?v=x55jfOd5PEE&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=24)

对应课本：[C++ Primer 19.3 枚举](https://cpp-primer.pages.dev/book/179-19.3._enumerations.html)

ENUM：给一组值（一般是数字）的名字。
* ENUM CLASS：只能在声明范围内使用。书本例子：

```cpp
enum color {red, yellow, green};      // unscoped enumeration
enum stoplight {red, yellow, green};  // error: redefines enumerators
enum class peppers {red, yellow, green}; // ok: enumerators are hidden
color eyes = green; // ok: enumerators are in scope for an unscoped enumeration
peppers p = green;  // error: enumerators from peppers are not in scope
                    //     color::green is in scope but has the wrong type
color hair = color::red;   // ok: we can explicitly access the enumerators
peppers p2 = peppers::red; // ok: using red from peppers
```

* 内外规定类型要一致。
`enum Example : unsigned char {A = 5,B,C};`

> [!note] EXample 16.1： 一个枚举
```
#include <iostream>

enum Example : unsigned char { // Enum with underlying type unsigned char
    A = 1,
    B = 2,
    C = 3
};

int main() {

    std::cin.get();

}
```

> [!note] EXample 16.2： Log Class里的枚举
```
#include <iostream>

class Log
{
public:
enum Level
{
    LevelError = 0,LevelWarning = 1,LevelInfo = 2
};

private:
    Level m_LogLevel = LevelInfo;//限制在Level范围内
public:
    void Setlevel(Level level)
    {
        m_LogLevel = level;
    }
    void Error(const char* message)
    {
        if (m_LogLevel >= LevelError)
        std::cout << "[ERROR]: " << message << std::endl; 
    }
    void Warn(const char* message)
    {
        if (m_LogLevel >= LevelWarning)
        std::cout << "[Warning]: " << message << std::endl;
    }
    void Info(const char* message)
    {
        if (m_LogLevel >= LevelInfo)
        std::cout << "[INFO]: " << message << std::endl;
    }
};

int main()
{
    Log log;
    log.Setlevel(Log::LevelError);// log类型（命名空间）里的Error类型。
    log.Warn("Hello!");
    log.Error("Hello!");
    log.Info("Hello!");
    std::cin.get();
}
```

### [Constructors in C++](https://www.youtube.com/watch?v=FXhALMsHwEY&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=24)

> [!note] EXample 17.1：没有初始化
```
#include <iostream>

class Entity
{
    public:
    float x, y;

    void Print()
    {
        std::cout << x << ", y << std::endl;
    }
};

int main()
{
    Entity e;
    e.Print();

    std::cin.get();
}
```

output:
两个随机的八位浮点。

我们没有初始那两个内存，这意味着 我们得到了该内存空间中剩余的任何东西。

> [!note] EXample 17.1：没有初始化
```
#include <iostream>

class Entity
{
    public:
    float x, y;

    void Print()
    {
        std::cout << x << ", y << std::endl;
    }
}
int main()
{
    Entity e;
    std::cout << e.X << std::endl;
    e.Print();

    std::cin.get();
}
```

> [!note] EXample 17.1.2：初始化
```
#include <iostream>

class Entity
{
    public:
    float X, Y;

    Entity()
    {

    }

    Entity(float x, float y)
    {
        X = x;
        Y = y;
    }

    void Print()
    {
        std::cout << X << ","<< Y << std::endl;
    }
};

class Log 
{
    private:
    Log(){}//构造函数私有化，禁止创建实例
    public:
    static void Write()
    {
        std::cout << "Log Created" << std::endl;
    }
};
int main()
{
    Log::Write();//只用我的class
//    Log 1;//这里会报错
    Entity e(5.0f, 10.0f);
    e.Print();

    std::cin.get();
}
```

其他类型的构造函数将放在之后讲：等

### [Destructors in C++](https://www.youtube.com/watch?v=D8cWquReFqw&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=25)

当你销毁对象时，析构函数会运行，它适用于堆栈和堆分配的对象。

> [!note] EXample 18.1：析构函数
```
#include <iostream>

class Entity
{
    public:
    float X, Y;

    Entity()
    {
        X = 0.0f;
        Y = 0.0f;
        std::cout << "Constructed Entity" << std::endl;
    }

    ~Entity()//析构函数
    {
        std::cout << "Entity Destroyed" << std::endl; 
    }
    void Print()
    {
        std::cout << X << ","<< Y << std::endl;
    }
};

void Function()
    {
        Entity e;
        e.Print();
    }

int main()
{
    Function();//函数调用，局部变量e在函数结束后会被销毁
    std::cin.get();
}

// 运行结果：
// Constructed Entity
// 0,0
// Entity Destroyed
// 说明：局部变量在函数结束后会被销毁，调用析构函数
}
```

析构函数会在堆栈运行完后运行↑至于为什么是堆栈↓
- 润润：没有new，所以是堆栈
- 润润：`Entity *e = new Entity()` 这种就是在堆上申请空间了。
- 我：懂了，只要没申请空间，都会最后消除实例
- 润润：NO，是因为**在堆栈上创建的变量，所以在生命周期结束的时候，会自动执行析构函数，也就是你说的消除实例**。
- 润润：时间点是**生命周期结束的时候**。
- 润润：因为**new的时候是用指针来引用了那个对象，“指针变量”还是会被回收，但是指针指向的对象不会**。
- 我：哦，指针也被析构了
- 润润：对，指针是个代理人，但是指针没有析构函数()，只是指针这个变量自己的空间被释放了
- 我：哦哦哦，他pop了，pippop~

Cherno谈到有人会手动调用析构函数：
- 一个是new function。
- 另一个是free function，
    - [有关自由函数的讨论 - 知乎](https://www.zhihu.com/question/269676755) 

### [Inheritance in C++](https://www.youtube.com/watch?v=X8nYM8wdNRE&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=26)

- 类的层次结构，它允许我们拥有一个包含常见功能的基类（base），然后它允许我们从该类中分支出来并从初始父类（parent）创建子类（sub）。
  - 能避免代码重复。
  - 子类是父类的superset，包含弗雷的所有参数，因此有时直接调用子类即可。
  - 子类能连同父类的private也一起继承，但是不能直接访问。
    - 一个public方法操作了私有变量，子类可以利用这个public方法来间接访问。【一川答】

> [!note] EXample 19.1：类的继承
```
#include <iostream>

class Entity {
public:
    float x, y;

    eoid Move(float xa, float ya) {
        x += xa;
        y += ya;
    }
};

class Player : public Entity {
public:
    const char* name;
    void print() 
    {
        std::cout << "Player: " << name << std::endl;
    }
};
int main() 
{
    Player player;
    player.print();
    player.Move(5, 10);
    player.x = 5;
    player.y = 10;
    std::cint.get();
}
```
#### 多态
Cherno：多态性是一种类型有多种类型的想法

> [!note] **润润小课堂：多态性**
> 多态分为静态多态和动态多态
> **静态多态**是函数的overload，就是多个函数有相同函数名，但是参数不同
> **动态多态**体现在**继承**叫override，子类拥有和父类一样的函数，但是具体的执行内容不同，这个是运行时根据类的虚函数表去查询执行的。

#### 父指针问题
- 一川：**父类指针**是不是可以自动识别这个实例是子类还是父类来着
- 润润：因为一个对象的内存开头保存了虚函数表的指针，也不叫识别是子类还是父类，都是根据这个指针去执行函数的
- 一川：我记得Cherno那节课讲过一个强制转换成某个派生类，哦，**向下转型**！

---
*以下源自deepseek*

在多重继承的情况下，`static_cast` 是否能正确转换父类与子类，取决于具体的转换方向和继承关系。以下是详细分析：

##### **1. 向上转型（子类 → 父类）**
**场景**：将子类指针/引用转换为父类指针/引用。  
**安全性**：  
- 如果父类是子类的直接公有基类（无论单继承还是多重继承），`static_cast` **是安全的**。编译器能正确调整指针地址，指向父类子对象的内存位置。  
- **多重继承示例**：  
  ```cpp
  class Base1 { /* ... */ };
  class Base2 { /* ... */ };
  class Derived : public Base1, public Base2 { /* ... */ };

  Derived d;
  Base1* b1 = static_cast<Base1*>(&d); // 安全：直接公有基类
  Base2* b2 = static_cast<Base2*>(&d); // 安全：直接公有基类
  ```
  **原理**：  
  编译器知道 `Derived` 对象中 `Base1` 和 `Base2` 子对象的偏移量，能自动调整指针地址。


##### **2. 向下转型（父类 → 子类）**
**场景**：将父类指针/引用转换为子类指针/引用。  
**风险**：  
- **仅在以下情况安全**：  
  父类指针实际指向的是目标子类对象，且开发者能 100% 确定类型关系。  
- **多重继承的隐患**：  
  如果父类指针指向的是其他子类（或同一继承树中的不同分支），`static_cast` **会静默生成错误指针**，导致未定义行为（崩溃、数据损坏等）。  

**示例**：  
```cpp
Base1* b1 = new Base1;  // 父类指针实际指向 Base1 对象
Derived* d = static_cast<Derived*>(b1); // 危险！b1 不是 Derived 对象
d->method(); // 未定义行为：访问非法内存
```

---

##### **3. 复杂多重继承场景**
###### **（1）虚继承（Virtual Inheritance）**
虚基类的内存布局在编译时无法确定（需运行时确定），因此：  
- **向上转型**：`static_cast` 依然安全，编译器能处理虚基类偏移。  
- **向下转型**：`static_cast` **几乎总是危险**，无法正确调整虚基类指针。必须使用 `dynamic_cast`。

###### **（2）交叉转换（Cross Cast）**
**场景**：在多重继承中，将指向一个基类的指针转换为另一个不相关的基类。  
**示例**：  
```cpp
Base1* b1 = new Derived;
Base2* b2 = static_cast<Base2*>(b1); // 编译错误：Base1 和 Base2 无直接继承关系
```
此时必须通过 `Derived` 中转：  
```cpp
Base2* b2 = static_cast<Derived*>(b1); // 先转为子类
b2 = static_cast<Base2*>(static_cast<Derived*>(b1)); // 再转为另一基类
```
但这种操作仍依赖 `b1` 实际指向 `Derived`，否则行为未定义。


##### **4. 与 `dynamic_cast` 的对比**
| 特性                | `static_cast`                          | `dynamic_cast`                          |
|---------------------|----------------------------------------|-----------------------------------------|
| **检查时机**         | 编译时                                | 运行时（依赖 RTTI）                     |
| **安全性**           | 依赖开发者保证逻辑正确                 | 自动验证类型兼容性                      |
| **性能**             | 无额外开销                            | 有运行时开销（遍历继承树）              |
| **适用场景**         | 明确安全的转换（如数值类型、向上转型） | 不确定类型时的向下转型、交叉转换        |
| **失败处理**         | 未定义行为                            | 返回 `nullptr`（指针）或抛出异常（引用）|

---

##### **5. 总结与建议**
- **向上转型**：  
  使用 `static_cast`，安全且高效（编译器保证正确性）。  
- **向下转型**：  
  - 如果无法 100% 确定父类指针实际指向子类对象，**必须使用 `dynamic_cast`**。  
  - 在多重继承或虚继承中，优先用 `dynamic_cast` 避免未定义行为。  
- **交叉转换**：  
  通过 `dynamic_cast` 直接完成，或先转为子类再转目标基类（需确保类型正确）。  

**关键原则**：  
**除非你能完全掌控类型关系，否则优先使用 `dynamic_cast` 保证安全性**。