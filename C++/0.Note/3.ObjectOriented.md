## 3.Object-Oriented
### [CLASSES in C++ -](https://www.youtube.com/watch?v=2BP8NhxjrO0&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=18)

class是对数据进行分组的方式，或将功能结合在一起。
class本质是一种Type。

class默认设置为private，需要声明public，才能被该类之外的地方可见。
类内部的函数称为方法（methods）。

> [!note] EXample 12.1：创建类玩家，让玩家移动
```cpp
class Player

{

public:

    int x, y;

    int speed;

};

  

void Move(Player& player, int xa, int ya)

{

    player.x += xa * player.speed;

    player.y += ya * player.speed;

}

int main()

{

   Player player;

    Move(player, 1, -1);

    std::cin.get();

}
```

> [!note] EXample 12.1.1：让玩家在类里移动
```cpp
class Player

{

public:

    int x, y;

    int speed;

  

    void Move(int xa, int ya)

{

    x += xa * speed;

    y += ya * speed;

}

};

  
  

int main()

{

   Player player;

   player.Move(1, -1);

  

    std::cin.get();

}
```

#### [CLASSES vs STRUCTS in C++](https://www.youtube.com/watch?v=fLgTtaqqJp0&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=19)

区别：几乎没有，唯有可见性问题，class默认private，structs默认public。

structs存在的原因：与C保持向后兼容性，因为C没有class

当然也可以，用struct 替换 class，但依旧会弹出class存在错误：

```cpp
#define struct class
```

T.cherno习惯在**只表示数据的结构**中用struct：

> [!note] EXample 12.2：struct
```cpp
struct Vec2
{
float x,y;
void Add(const Vec2& other)
{
    x += other.x;
    y += other.y;
}
};
```

如果涉及到大量功能，他会使用class。

### [How to Write a C++ Class](https://www.youtube.com/watch?v=3dHBFBw13E0&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=21)

示例class log：error、warning、message、trace

用多个public、private区分变量和公式。

> [!note] EXample 13.1：class Log
```cpp
class Log
{
public:
    const int LogLevelError = 0;
    const int LogLevelWarming = 1;
    const int LogLevelInfo = 2;
private:
    int m_LogLevel = LogLevelInfo;//m_来标识它是一个私人成员变量，个人设定，非keyword
public:
    void Setlevel(int level)
    {
        m_LogLevel = level;
    }
    void Error(const char* message)
    {
        if (m_LogLevel >= LogLevelError)
        std::cout << "[ERROR]: " << message << std::endl; 
    }
    void Warn(const char* message)
    {
        if (m_LogLevel >= LogLevelWarming)
        std::cout << "[Warning]: " << message << std::endl;
    }
    void Info(const char* message)
    {
        if (m_LogLevel >= LogLevelInfo)
        std::cout << "[INFO]: " << message << std::endl;
    }
};

int main()
{
    Log log;
    log.Setlevel(log.LogLevelError);
    log.Warn("Hello!");
    log.Error("Hello!");
    log.Info("Hello!");
    std::cin.get();
}
```

### [Static in C++](https://www.youtube.com/watch?v=f3FVU-iwNuA&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=21)
 
 static：类与结构之外者，具有内部含义，只对定义它的翻译单元可见。
 
 类与结构之内者，与该类的所有实例共享内存，和类绑定！
 - 人话：一个公式改变了它的量，其他公式里的它也会同时改变。
 
 1.如果删掉static，会出现LNK错误。
 
 2.如果加上extern，即和外部用同一个变量，外部链接。
 - extern int  s_Variable;
 
 3.如果加上static，main.cpp里的extern int s_Variable会找不到变量。
 
 4.如果加上static，Function()函数只能在本文件中使用，
 
 > [!note] EXample 14.main
 ```cpp
 #include <iostream>
 
 int  s_Variable = 10;
 // 2.如果加上extern，即和外部用同一个变量，外部链接。
 // extern int  s_Variable;
 
 void Function()
 {
 
 }
 
 int main()
 {
     std::cout << s_Variable << std::endl;
     std::cin.get();
 }
 ```
 
 > [!note] EXample 14.static
 ```cpp
 #include <iostream>
 
 static int  s_Variable = 5; 
 // 1.如果删掉static，会出现LNK错误。
 
 // 3.如果加上static，main.cpp里的extern int s_Variable会找不到变量。
 
 static void Function()
 {
     std::cout << s_Variable << std::endl;
     std::cin.get();
 }
 //4.如果加上static，Function()函数只能在本文件中使用，
 ```
 
 #### [Static for Classes and Structs in C++](https://www.youtube.com/watch?v=V-BFlMrBtqQ&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=23)
 
 > [!note] EXample 15.1 一个正常的输出
 ```cpp
 #include <iostream>
 
 struct Entity
 {
     int x, y;
 
     void Print()
     {
         std::cout << x << ", " << y << std::endl;
     }
 };
 
 int main()
 {
     Entity e;
     e.x = 5;
     e.y = 10;
 
     Entity e1 = {2, 8};
 
     e.Print();
     e1.Print();
     std::cin.get();
 }
 
 > [!note] EXample 15.2 一个有静态变量但错误的输出
 ```cpp
 struct Entity
 {
     static int x, y;
 
     void Print()
     {
         std::cout << x << ", " << y << std::endl;
     }
 };
 
 int main()
 {
     Entity e;
     e.x = 5;
     e.y = 10;
 
     Entity e1;
     e1.x = 2;
     e1.y = 8;
     // Entity e1 = {2, 8}; // x和y是静态成员变量，而不是class menbers，不能直接初始化。
     //这样会显示无法识别的外部变量。
 
     e.Print();
     e1.Print();
     std::cin.get();
 }
 ```
 
 > [!note] EXample 15.3 一个有静态变量的输出
 ```cpp
 struct Entity
 {
     static int x, y;
 
 static void Print()
 //    void Print()
     {
         std::cout << x << ", " << y << std::endl;
 		//如果将line 5静态变量改为普通变量，则会出现报错，因为它没有类实例
     }
 };
 
 static void Print(Entity e)
 {
     std::cout << Entity::x << ", " << Entity::y << std::endl;
     //但是如果在外部调用struct，line 5改为普通变量时可以使用，因为给了这个函数实例的引用，实例entity是非静态的。
 }
 int Entity::x = 0; // 静态成员变量必须在类外初始化
 int Entity::y = 0; // 静态成员变量必须在类外初始化
 
 int main()
 {
     Entity e;
 	Entity::x = 5;
     Entity::y = 10;
     //e.x = 5;
     //e.y = 10;
 
     Entity e1;
     Entity::x = 2;
     Entity::y = 8;
     //e1.x = 2;
     //e1.y = 8;
 
 Entity Print();
 //    e.Print();
 //    e1.Print();
     std::cin.get();
 }
 //实质为不断修改static变量和方程，和实例无关。
 ```

 ### [ENUMS in C++](https://www.youtube.com/watch?v=x55jfOd5PEE&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=24)

对应课本：[C++ Primer 19.3 枚举](https://cpp-primer.pages.dev/book/179-19.3._enumerations.html)

ENUM：给一组值（一般是数字）的名字。
* ENUM CLASS：只能在声明范围内使用。书本例子：

```
enum color {red, yellow, green};      // unscoped enumeration
enum stoplight {red, yellow, green};  // error: redefines enumerators
enum class peppers {red, yellow, green}; // ok: enumerators are hidden
color eyes = green; // ok: enumerators are in scope for an unscoped enumeration
peppers p = green;  // error: enumerators from peppers are not in scope
                    //     color::green is in scope but has the wrong type
color hair = color::red;   // ok: we can explicitly access the enumerators
peppers p2 = peppers::red; // ok: using red from peppers
```

* 内外规定类型要一致。
`enum Example : unsigned char {A = 5,B,C};`

> [!note] EXample 16.1： 一个枚举
```
#include <iostream>

enum Example : unsigned char { // Enum with underlying type unsigned char
    A = 1,
    B = 2,
    C = 3
};

int main() {

    std::cin.get();

}
```

> [!note] EXample 16.2： Log Class里的枚举
```
#include <iostream>

class Log
{
public:
enum Level
{
    LevelError = 0,LevelWarning = 1,LevelInfo = 2
}

private:
    Level m_LogLevel = Info;//限制在Level范围内
public:
    void Setlevel(Level level)
    {
        m_LogLevel = level;
    }
    void Error(const char* message)
    {
        if (m_LogLevel >= LevelError)
        std::cout << "[ERROR]: " << message << std::endl; 
    }
    void Warn(const char* message)
    {
        if (m_LogLevel >= LevelWarning)
        std::cout << "[Warning]: " << message << std::endl;
    }
    void Info(const char* message)
    {
        if (m_LogLevel >= LevelInfo)
        std::cout << "[INFO]: " << message << std::endl;
    }
};

int main()
{
    Log log;
    log.Setlevel(Log::Error);// log类型（命名空间）里的Error类型。
    log.Warn("Hello!");
    log.Error("Hello!");
    log.Info("Hello!");
    std::cin.get();
}
```


### [Constructors in C++](https://www.youtube.com/watch?v=FXhALMsHwEY&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=24)

> [!note] EXample 17.1：没有初始化
```
#include <iostream>

class Entity
{
    public:
    float x, y;

    void Print()
    {
        std::cout << x << ", y << std::endl;
    }
}

int main()
{
    Entity e;
    e.Print();

    std::cin.get();
}
```

output:
两个随机的八位浮点。

我们没有初始那两个内存，这意味着 我们得到了该内存空间中剩余的任何东西。

> [!note] EXample 17.1：没有初始化
```
#include <iostream>

class Entity
{
    public:
    float x, y;

    void Print()
    {
        std::cout << x << ", y << std::endl;
    }
}

int main()
{
    Entity e;
    std::cout << e.X << std::endl;
    e.Print();

    std::cin.get();
}

> [!note] EXample 17.1.2：初始化
```
#include <iostream>

class Entity
{
    public:
    float x, y;

    Entity()
    {
        x = 0.0f;
        y = 0.0f;
    }

    void Print()
    {
        std::cout << x << ","<< y << std::endl;
    }
}

int main()
{
    Entity e;
    std::cout << e.x << std::endl;
    e.Print();

    std::cin.get();
}
```

只有在C++里，才需要初始化，像是JAVA就不需要

还有另一种初始方法：`Entity e(5.0f, 10.0f);`,见代码。


> [!note] EXample 17.2：私有初始化，不创造实例
```
class Log 
{
    private:
    Log(){}//构造函数私有化，禁止创建实例
    public:
    static void Write()
    {
        std::cout << "Log Created" << std::endl;
    }
};
int main()
{
    Log::Write();//只用我的class
    Log 1;//这里会报错
    Entity e(5.0f, 10.0f);
    e.Print();

    std::cin.get();
}
```

其他类型的构造函数将放在之后讲：等

### [Destructors in C++](https://www.youtube.com/watch?v=D8cWquReFqw&list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&index=25)

当你销毁对象时，析构函数会运行，它适用于堆栈和堆分配的对象。

> [!note] EXample 18.1：析构函数
```
#include <iostream>

class Entity
{
    public:
    float X, Y;

    Entity()
    {
        X = 0.0f;
        Y = 0.0f;
        std::cout << "Constructed Entity" << std::endl;
    }

    ~Entity()//析构函数
    {
        std::cout << "Entity Destroyed" << std::endl; 
    }
    void Print()
    {
        std::cout << X << ","<< Y << std::endl;
    }
}

void Function()
    {
        Entity e;
        e.Print();
    }

int main()
{
    Function();//函数调用，局部变量e在函数结束后会被销毁
    std::cin.get();
}

// 运行结果：
// Constructed Entity
// 0,0
// Entity Destroyed
// 说明：局部变量在函数结束后会被销毁，调用析构函数
}
```

析构函数会在堆栈运行完后运行↑至于为什么是堆栈↓
- 润润：没有new，所以是堆栈
- 润润：`Entity *e = new Entity()` 这种就是在堆上申请空间了。
- 我：懂了，只要没申请空间，都会最后消除实例
- 润润：NO，是因为**在堆栈上创建的变量，所以在生命周期结束的时候，会自动执行析构函数，也就是你说的消除实例**。
- 润润：时间点是**生命周期结束的时候**。
- 润润：因为**new的时候是用指针来引用了那个对象，“指针变量”还是会被回收，但是指针指向的对象不会**。
- 我：哦，指针也被析构了
润润：对，指针是个代理人，但是指针没有析构函数()

Cherno谈到有人会手动调用析构函数：
- 一个是new function。
- 另一个是free function，
    - [有关自由函数的讨论 - 知乎](https://www.zhihu.com/question/269676755) 


